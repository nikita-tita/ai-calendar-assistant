# Анализ проблемы: Отказ Yandex GPT обрабатывать запросы на создание событий

**Дата**: 2025-11-29
**Приоритет**: КРИТИЧЕСКИЙ
**Затронутая функциональность**: Создание множественных событий через голосовой ввод

---

## 1. ЧТО БЫЛО (рабочее состояние)

### Ожидаемое поведение:
- Пользователь отправляет голосовое/текстовое сообщение с множественными событиями
- Пример: "Поставь на 10 утра завтра предварительно договориться с максимом по поводу встреч после обеда И Съездить в зал в 8 вечера"
- Бот распознаёт голос → транскрибирует текст → отправляет в Yandex GPT
- Yandex GPT возвращает JSON с распарсенными событиями
- Бот создаёт события в календаре

### Архитектура обработки:
```
Telegram Voice Message
  → Voice Recognition (Telegram API)
  → Text: "Поставь на 10 утра..."
  → llm_agent_yandex.extract_intent()
    → Формирование промпта с:
      - Системный промпт (правила парсинга)
      - Контекст существующих событий (19 событий)
      - Текст пользователя
      - JSON schema для ответа
    → Yandex GPT API call
    → Парсинг JSON ответа
  → Создание событий в календаре
```

---

## 2. ЧТО СЛОМАЛОСЬ

### Симптомы:
1. **Отказ Yandex GPT API**:
   ```
   yandex_gpt_raw_response: "Я не могу обсуждать эту тему. Давайте поговорим о чём-нибудь ещё."
   ```

2. **Ошибка парсинга JSON**:
   ```
   yandex_gpt_json_parse_error: No JSON found in response
   ```

3. **Результат для пользователя**:
   - Бот отвечает: "Не могли бы вы переформулировать ваш запрос?"
   - События не создаются

### Логи проблемного запроса:
```
[11:38:18] llm_extract_start_yandex: user_text="Поставь на 10 утра завтра..."
[11:38:18] yandex_gpt_api_call: event_id_enum=['none', 'efe16976...', ...] (19 событий)
[11:38:19] yandex_gpt_raw_response: "Я не могу обсуждать эту тему..."
[11:38:19] yandex_gpt_json_parse_error: No JSON found
[11:38:19] llm_extract_success_yandex: intent=clarify, confidence=0.2
```

---

## 3. ПРИЧИНЫ ПРОБЛЕМЫ

### Основная причина: Модерация контента Yandex GPT

**Yandex GPT отклоняет запрос из-за срабатывания контентных фильтров.**

### Возможные триггеры:

1. **Большой размер промпта** (19 существующих событий в контексте)
   - В логах видно: `event_id_enum` содержит 20 элементов (none + 19 ID событий)
   - Каждое событие добавляет в промпт: название, время, ID
   - Суммарно может превышать лимит токенов или триггерить проверки

2. **Формат перечисления событий**
   - События передаются как:
   ```
   Event: Показ квартиры на Матросова
   Time: 25.11.2025 19:00
   ID: efe16976-30f5-46d6-989d-1bbf68f91991
   ```
   - Возможно, формат или содержание событий триггерит модерацию

3. **Конкретные слова в запросе**
   - "максим" (имя человека)
   - "встречи после обеда"
   - Yandex может считать это личной перепиской

4. **Непоследовательность API**
   - За 1 минуту до проблемного запроса были 2 успешных запроса
   - Это говорит о том, что проблема не в коде, а в API behavior

### Что НЕ является причиной:
- ✅ **Мои изменения в telegram_handler.py** - они касались только обработки кнопок Задачи и Полезное
- ✅ **Изменения в llm_agent_yandex.py** - этот файл не трогался
- ✅ **Проблемы с voice recognition** - текст корректно распознан

---

## 4. КАК УСТРАНИТЬ

### Решение 1: Ограничить контекст существующих событий (РЕКОМЕНДУЕТСЯ)

**Суть**: Не отправлять все 19 событий в Yandex, а только релевантные.

**Изменения в `llm_agent_yandex.py`**:

```python
# Было: отправляем все события
if existing_events and len(existing_events) > 0:
    for event in existing_events:
        events_prefix += f"\nEvent: {event.summary}\n"
        events_prefix += f"Time: {event.start_local.strftime('%d.%m.%Y %H:%M')}\n"
        events_prefix += f"ID: {event.id}\n"

# Стало: отправляем только последние 5 событий или события на завтра
max_events_in_context = 5
relevant_events = existing_events[:max_events_in_context] if existing_events else []

for event in relevant_events:
    events_prefix += f"\nEvent: {event.summary}\n"
    events_prefix += f"Time: {event.start_local.strftime('%d.%m.%Y %H:%M')}\n"
    events_prefix += f"ID: {event.id}\n"

# И соответственно ограничить event_id_enum
event_id_enum = ["none"]
for event in relevant_events:
    if hasattr(event, 'id') and event.id:
        event_id_enum.append(str(event.id))
```

**Преимущества**:
- Уменьшает размер промпта
- Снижает вероятность срабатывания модерации
- Быстрее обработка

**Недостатки**:
- Не сможет редактировать/удалять события старше определённого порога

---

### Решение 2: Fallback на упрощённый парсинг

**Суть**: Если Yandex отказывает, использовать regex/rule-based парсинг для простых случаев.

**Добавить в `llm_agent_yandex.py`**:

```python
# После получения отказа от Yandex
if "не могу обсуждать" in result_text.lower():
    logger.warning("yandex_content_filter_triggered", user_text=user_text)

    # Fallback: простой regex парсинг
    return self._fallback_simple_parse(user_text, current_time)

def _fallback_simple_parse(self, user_text, current_time):
    """Упрощённый парсинг для случаев, когда Yandex отказывает."""
    # Ищем паттерны типа "в 10 утра", "завтра", "в 8 вечера"
    # Парсим без LLM, используя простые правила
    # ...
```

**Преимущества**:
- Работает даже при отказе Yandex
- Быстрее

**Недостатки**:
- Менее точный парсинг
- Не поддерживает сложные запросы

---

### Решение 3: Разделить запрос на части

**Суть**: Если запрос содержит "И" или несколько событий, разделить на отдельные запросы к Yandex.

```python
# Определить множественность
if " и " in user_text.lower() or " И " in user_text:
    # Разделить на части
    parts = re.split(r'\s+[иИ]\s+', user_text)

    # Отправить каждую часть отдельно
    results = []
    for part in parts:
        result = self._single_extract(part, existing_events, current_time)
        results.append(result)

    return {"intent": "batch_confirm", "actions": results}
```

**Преимущества**:
- Меньшие промпты
- Каждая часть проще для модерации

**Недостатки**:
- Больше API calls
- Может неправильно разделить сложные запросы

---

## 5. КАК БОЛЬШЕ НЕ ЛОМАТЬ

### Процедура изменений на проде:

1. **НИКОГДА не менять код на проде без тестирования**
   - Все изменения сначала тестировать локально
   - Создавать отдельную staging среду

2. **Перед изменением:**
   - Прочитать весь связанный код
   - Понять зависимости
   - Проверить что работает сейчас
   - Создать backup

3. **При изменении:**
   - Менять только то, что нужно
   - Не трогать несвязанные модули
   - Коммитить по частям с понятными сообщениями

4. **После изменения:**
   - Проверить логи на ошибки
   - Протестировать все затронутые функции
   - Убедиться что ничего не сломалось

5. **Rollback plan:**
   - Всегда иметь план отката
   - Знать какой коммит был рабочим
   - Уметь быстро восстановить из backup

### Конкретно для этого кейса:

- ✅ **llm_agent_yandex.py** - не трогать без крайней необходимости
- ✅ **telegram_handler.py** - изменения только в обработчиках кнопок
- ✅ **Тестировать на staging** - перед deploy на прод
- ✅ **Мониторить логи Yandex API** - отслеживать отказы

---

## 6. РЕКОМЕНДАЦИИ

### Немедленные действия:

1. **Реализовать Решение 1**: Ограничить контекст до 5-10 последних событий
2. **Добавить обработку ошибок**: Если Yandex отказывает, логировать детали
3. **Тестирование**: Проверить что множественные события снова работают

### Долгосрочные улучшения:

1. **Добавить retry логику**: Если Yandex отказал, повторить запрос без контекста событий
2. **Метрики**: Отслеживать частоту отказов Yandex
3. **Альтернативный LLM**: Рассмотреть fallback на другую модель (OpenAI, Claude)
4. **Staging окружение**: Создать тестовую среду для проверки изменений

---

## 7. ЗАКЛЮЧЕНИЕ

**Проблема**: Yandex GPT отклоняет запросы из-за контентной модерации
**Причина**: Большой размер промпта (19 событий) + возможно триггерные слова
**Не связано с**: Моими изменениями в telegram_handler.py
**Решение**: Ограничить количество событий в контексте до 5-10
**Время на fix**: 30 минут
**Риск**: Низкий (изменения только в llm_agent_yandex.py)

---

**Следующий шаг**: Получить одобрение на Решение 1 и внедрить.
