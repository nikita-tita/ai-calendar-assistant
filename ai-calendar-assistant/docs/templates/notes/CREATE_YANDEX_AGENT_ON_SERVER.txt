#!/bin/bash
# Команды для создания llm_agent_yandex.py на сервере
# Подключись к серверу: ssh root@91.229.8.221
# Затем скопируй и выполни эту команду:

cat > /root/ai-calendar-assistant/app/services/llm_agent_yandex.py << 'ENDOFFILE'
"""LLM Agent service using Yandex GPT (YandexGPT Foundation Models)."""

from typing import Optional
import json
from datetime import datetime, timedelta
import requests
import structlog

from app.config import settings
from app.schemas.events import EventDTO, IntentType
from app.utils.datetime_parser import parse_datetime_range

logger = structlog.get_logger()


class LLMAgentYandex:
    """
    LLM Agent for understanding natural language calendar commands.

    Uses Yandex GPT (YandexGPT) with function calling to extract structured
    event information from user queries.

    This is a drop-in replacement for Anthropic Claude agent,
    preserving all logic for update/delete operations with existing_events.
    Works from Russia without restrictions.
    """

    def __init__(self):
        """Initialize LLM agent with Yandex GPT client."""
        self.api_key = settings.yandex_gpt_api_key
        self.folder_id = settings.yandex_gpt_folder_id
        self.model = "yandexgpt"
        self.api_url = "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"

        self.base_system_prompt = """Ты - интеллектуальный календарный ассистент.
Твоя задача - понимать команды пользователя на естественном языке (русском или английском)
и преобразовывать их в структурированные действия с календарем.

Возможные действия (intent):
- create: создать новое событие
- update: изменить существующее событие
- delete: удалить событие
- query: запросить информацию о событиях
- find_free_slots: найти свободное время
- clarify: запросить уточнение, если данных недостаточно

Правила:
1. Всегда возвращай время в формате ISO 8601 с таймзоной указанной для пользователя
2. Если не хватает информации (даты, времени, названия) - используй intent=clarify
3. ВАЖНО: Для относительных дат (завтра, послезавтра, в пятницу) вычисляй конкретную дату относительно ТЕКУЩЕЙ ДАТЫ
4. ВАЖНО: Если дата НЕ указана явно и НЕ является относительной - используй intent=clarify
5. ВАЖНО: Используй контекст предыдущих сообщений - если пользователь отвечает на уточняющий вопрос, дополни информацию из истории
6. Длительность по умолчанию - 60 минут, если не указано иное
7. Извлекай участников из текста (имена, email)

Примеры команд:
- "Встреча с командой завтра в 10" -> create, title="Встреча с командой", start=завтра 10:00
- "Что у меня на завтра?" -> query, query_date_start=завтра
- "Свободное время в пятницу" -> find_free_slots, query_date_start=пятница

ВАЖНО: Твой ответ должен быть ТОЛЬКО в формате JSON с полями из схемы функции set_calendar_action.
Не добавляй никакого текста до или после JSON."""

    async def extract_event(
        self,
        user_text: str,
        user_id: Optional[str] = None,
        conversation_history: Optional[list] = None,
        timezone: str = 'Europe/Moscow',
        existing_events: Optional[list] = None
    ) -> EventDTO:
        """Extract structured event information from natural language text."""
        logger.info("llm_extract_start_yandex", user_text=user_text, user_id=user_id)

        try:
            import pytz
            tz = pytz.timezone(timezone)
            now = datetime.now(tz)
            current_date_str = now.strftime('%d.%m.%Y')
            current_datetime_str = now.strftime('%d.%m.%Y %H:%M')
            current_weekday = now.strftime('%A')

            weekdays_ru = {
                'Monday': 'понедельник',
                'Tuesday': 'вторник',
                'Wednesday': 'среда',
                'Thursday': 'четверг',
                'Friday': 'пятница',
                'Saturday': 'суббота',
                'Sunday': 'воскресенье'
            }
            current_weekday_ru = weekdays_ru.get(current_weekday, current_weekday)

            tz_offset = now.strftime('%z')
            tz_offset_formatted = f"{tz_offset[:3]}:{tz_offset[3:]}"

            events_prefix = ""
            if existing_events and len(existing_events) > 0:
                events_prefix = "<existing_calendar_events>\n"
                for event in existing_events:
                    event_time = event.start.strftime('%d.%m.%Y %H:%M') if hasattr(event, 'start') else 'Unknown'
                    event_title = event.summary if hasattr(event, 'summary') else 'No title'
                    event_id = event.id if hasattr(event, 'id') else 'unknown'
                    events_prefix += f"Event: {event_title}\nTime: {event_time}\nID: {event_id}\n\n"
                events_prefix += """</existing_calendar_events>

CRITICAL: For update/delete operations:
- Find the event in the list above by matching title/description
- COPY the exact ID value - NEVER use "unknown"

User request:
"""

            system_prompt = f"""{self.base_system_prompt}

ВАЖНО: ТЕКУЩАЯ ДАТА И ВРЕМЯ: {current_datetime_str} ({timezone}, UTC{tz_offset_formatted}), {current_weekday_ru}
Используй эту дату для расчета относительных дат (завтра, послезавтра, через неделю и т.д.)

Примеры относительных дат от ТЕКУЩЕЙ ДАТЫ ({current_date_str}):
- "завтра" = {(now + timedelta(days=1)).strftime('%d.%m.%Y')}
- "послезавтра" = {(now + timedelta(days=2)).strftime('%d.%m.%Y')}
- "через неделю" = {(now + timedelta(days=7)).strftime('%d.%m.%Y')}
"""

            start_time, end_time, duration = parse_datetime_range(user_text)

            event_id_enum = ["none"]
            if existing_events and len(existing_events) > 0:
                for event in existing_events:
                    if hasattr(event, 'id') and event.id:
                        event_id_enum.append(str(event.id))

            user_message_content = events_prefix + user_text

            function_schema = {
                "name": "set_calendar_action",
                "description": "Установить действие с календарем на основе команды пользователя",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "intent": {
                            "type": "string",
                            "enum": ["create", "update", "delete", "query", "find_free_slots", "clarify"],
                            "description": "Тип действия"
                        },
                        "title": {"type": "string", "description": "Название события"},
                        "start_time": {"type": "string", "description": "Время начала в ISO 8601"},
                        "end_time": {"type": "string", "description": "Время окончания в ISO 8601"},
                        "duration_minutes": {"type": "integer", "description": "Длительность в минутах"},
                        "location": {"type": "string", "description": "Место встречи"},
                        "attendees": {"type": "array", "items": {"type": "string"}},
                        "event_id": {"type": "string", "enum": event_id_enum},
                        "clarify_question": {"type": "string"},
                        "query_date_start": {"type": "string"},
                        "query_date_end": {"type": "string"},
                        "confidence": {"type": "number"}
                    },
                    "required": ["intent"]
                }
            }

            full_prompt = f"""{system_prompt}

{user_message_content}

Верни ТОЛЬКО JSON с полями функции set_calendar_action. Схема функции:
{json.dumps(function_schema, ensure_ascii=False, indent=2)}

JSON ответ:"""

            logger.debug("yandex_gpt_api_call", event_id_enum=event_id_enum)

            headers = {
                "Authorization": f"Api-Key {self.api_key}",
                "Content-Type": "application/json"
            }

            payload = {
                "modelUri": f"gpt://{self.folder_id}/{self.model}/latest",
                "completionOptions": {
                    "stream": False,
                    "temperature": 0.2,
                    "maxTokens": 2000
                },
                "messages": [
                    {"role": "system", "text": full_prompt}
                ]
            }

            response = requests.post(self.api_url, headers=headers, json=payload, timeout=30)

            if response.status_code != 200:
                logger.error("yandex_gpt_api_error", status_code=response.status_code, response=response.text)
                raise Exception(f"Yandex GPT API error: {response.status_code} - {response.text}")

            response_data = response.json()
            logger.debug("llm_response_yandex", response=response_data)

            result_text = response_data.get("result", {}).get("alternatives", [{}])[0].get("message", {}).get("text", "")

            event_dto = self._parse_yandex_response(result_text, user_text, start_time, end_time, duration)

            logger.info("llm_extract_success_yandex", intent=event_dto.intent, confidence=event_dto.confidence)

            return event_dto

        except Exception as e:
            logger.error("llm_extract_error_yandex", error=str(e), exc_info=True)
            return EventDTO(
                intent=IntentType.CLARIFY,
                confidence=0.0,
                clarify_question="Извините, я не совсем понял. Не могли бы вы переформулировать?",
                raw_text=user_text
            )

    def _parse_yandex_response(
        self,
        result_text: str,
        user_text: str,
        parsed_start: Optional[datetime],
        parsed_end: Optional[datetime],
        parsed_duration: Optional[int]
    ) -> EventDTO:
        """Parse Yandex GPT API response into EventDTO."""

        try:
            start_idx = result_text.find('{')
            end_idx = result_text.rfind('}') + 1

            if start_idx == -1 or end_idx == 0:
                raise ValueError("No JSON found in response")

            json_str = result_text[start_idx:end_idx]
            input_data = json.loads(json_str)

        except (json.JSONDecodeError, ValueError) as e:
            logger.warning("yandex_gpt_json_parse_error", error=str(e), text=result_text)
            return EventDTO(
                intent=IntentType.CLARIFY,
                confidence=0.2,
                clarify_question="Не могли бы вы переформулировать?",
                raw_text=user_text
            )

        intent = IntentType(input_data.get("intent", "clarify"))

        start_time = None
        end_time = None

        if "start_time" in input_data:
            try:
                start_time = datetime.fromisoformat(input_data["start_time"])
            except:
                start_time = parsed_start

        if "end_time" in input_data:
            try:
                end_time = datetime.fromisoformat(input_data["end_time"])
            except:
                end_time = parsed_end

        if not start_time:
            start_time = parsed_start
        if not end_time:
            end_time = parsed_end

        duration_minutes = input_data.get("duration_minutes", parsed_duration)

        event_dto = EventDTO(
            intent=intent,
            confidence=input_data.get("confidence", 0.75),
            title=input_data.get("title"),
            description=None,
            start_time=start_time,
            end_time=end_time,
            duration_minutes=duration_minutes,
            location=input_data.get("location"),
            attendees=input_data.get("attendees", []),
            event_id=input_data.get("event_id"),
            clarify_question=input_data.get("clarify_question"),
            query_date_start=self._parse_optional_datetime(input_data.get("query_date_start")),
            query_date_end=self._parse_optional_datetime(input_data.get("query_date_end")),
            raw_text=user_text
        )

        return event_dto

    def _parse_optional_datetime(self, dt_str: Optional[str]) -> Optional[datetime]:
        """Parse optional datetime string."""
        if not dt_str:
            return None
        try:
            return datetime.fromisoformat(dt_str)
        except:
            return None


llm_agent_yandex = LLMAgentYandex()
ENDOFFILE

echo "✅ Файл llm_agent_yandex.py создан"
ls -lah /root/ai-calendar-assistant/app/services/llm_agent_yandex.py
